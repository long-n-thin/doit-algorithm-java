# 검색과 복잡도

- [검색과 복잡도](#검색과-복잡도)
  - [배열의 검색](#배열의-검색)
    - [선형 검색(linear search)](#선형-검색linear-search)
    - [이진 검색(binary search)](#이진-검색binary-search)
  - [복잡도](#복잡도)
    - [시간복잡도(Time Complexity, 계산 시간)](#시간복잡도time-complexity-계산-시간)
      - [실행 시간 running time](#실행-시간-running-time)
      - [빅오 표기법](#빅오-표기법)
      - [알고리즘 계산: 더하기 vs 곱하기](#알고리즘-계산-더하기-vs-곱하기)
      - [많이 사용하는 빅오 실행 시간](#많이-사용하는-빅오-실행-시간)
    - [공간 복잡도(Space Complexity)](#공간-복잡도space-complexity)
      - [공간 복잡도 예시](#공간-복잡도-예시)

## 배열의 검색

### 선형 검색(linear search)

- a.k.a. 순차검색(sequential search)
- 가장 단순한 검색법
- 배열의 앞에서부터 순서대로 요소를 검색한다.
- 데이터수가 많고 검색대상이 배열 뒤쪽에 있는 경우, 또는 대상이 없는 경우 비교 횟수가 많아져서 시간이 오래 걸린다.
- 1부터 n까지 순서대로 찾으면 최대 n번, 평균 n/2번 걸린다.
- 데이터가 많은 경우 사용하기에는 적합하지 않다.

### 이진 검색(binary search)

- 배열의 데이터가 오름차순/내림차순으로 정렬된 경우에만 사용할 수 있다.
- 배열의 중간을 기준으로 찾으려는 값과 비교하면 검색 범위를 반으로 줄일 수 있다.
  - 배열의 중간값과 대소 비교후 해당되지 않는 반은 버린다.
  - 남은 반의 중간값을 찾고 위의 문장을 반복한다.

## 복잡도

- 복잡도: 알고리즘 성능의 객관적 평가 기준
- 시간 복잡도(time complexity): 실행에 필요한 시간을 평가한 것
- 공간 복잡도(space complexity): 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것

### 시간복잡도(Time Complexity, 계산 시간)

- 입력 데이터의 크기가 늘어날 때 알고리즘 실행 속도가 얼마나 증가하는지 알 수 있다.
- Big-O(빅 오)
  - 시간의 상한. 최악의 경우보다 적거나 같다.
  - O(n^2)은 계산 시간이 최악의 경우 n^2의 배수가 된다는 것을 의미한다.
  - 선형 검색 알고리즘은 O(n)의 시간이 걸리고, O(n)보다 느려지지 않는다.
- Big-Ω(빅 오메가)
  - 시간의 하한. 최선의 경우보다 크거나 같다.
  - 선형 검색 알고리즘은 Ω(n)의 시간이 걸리고, Ω(n)보다 빨라지지 않는다.
- Big-Θ(빅 세타)
  - 평군 실행 시간을 나타낸다.
  - O(n)이면서 Ω(n)이면 Θ(n)이다.

```text
best <= Big-Ω <= Big-Θ <= Big-O <= worst
```

#### 실행 시간 running time

- 프로그램이 시작해서 종료까지 걸리는 시간

|| 단순 검색 | 이진 검색 |
|:---:|:---:|:---:|
| 100개 | 100번 | 7번 |
| 10,000개 | 10,000번 | 14번 |
| 1,000,000,000개 | 10억 번 | 32번 |
|실행 시간| 선형 시간 | 로그 시간 |
|빅오 표기| O(n) | O(log n) |

- 알고리즘의 속도는 시간이 아닌 연산 횟수가 어떻게 증가하는지로 측정한다.
- 실행 시간은 선형적으로 증가하지 않는다.  
  <img width="600px" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/1280px-Comparison_computational_complexity.svg.png">

#### 빅오 표기법

- `O`는 `오더` 또는 `빅오`라고 읽고, `중요한 항목 이외는 무시한다`는 의미이다.
- 알고리즘의 속도를 표시하는 방법이다.
- 빅오 표기를 보면 알고리즘 계산 시간을 직관적으로 이해할 수 있다.
- 상수항과 지배적이지 않은 항 무시하기
  - O(n+2) => O(n)
  - O(n^2+n) => O(n^2)

#### 알고리즘 계산: 더하기 vs 곱하기

- 알고리즘이 여러 부분으로 이루어져 있을 때, 수행시간을...
  - 더하는 경우 - A를 다 끝내고 B를 수행
  - 곱하는 경우 - A를 하나 할 때마다 B를 수행

```java
// 수행시간 더하기: O(A+B)
for (int a : arrA) { ... }
for (int b : arrB) { ... }

// 수행시간 곱하기: O(A*B)
for (int a : arrA) {
  for (int b : arrB) { ... }
}
```

#### 많이 사용하는 빅오 실행 시간

| Complexity | Name | Example |
|---|---|---|
| O(1) | constant | 특정 값 출력, 홀짝 구별 |
| O(log n) | logarithmic | 이진 검색 |
| O(n) | linear | 선형 검색 |
| O(n lon n) | linearithmic | 퀵 정렬, Heap 정렬 |
| O(n^2) | quadratic | 삽입 정렬, 선택 정렬, 이중 for문 |
| O(n!) | exponential | 이중 재귀 |

### 공간 복잡도(Space Complexity)

- 프로그램 실행시 실제 사용되는 메모리 공간의 양
- 크기가 n인 배열은 O(n) 공간 필요
- 크기가 n*n인 2차원 배열은 O(n^2) 공간 필요

#### 공간 복잡도 예시

- 재귀 호출을 사용해 합을 구하는 함수
- 이전 함수의 결과값을 기억해야 하기 때문에 함수를 호출할 때마다 스택 깊이가 깊어지고, 호출 스택에 모든 호출이 더해진다.
- n번 호출하면 n개의 호출이 호출스택에 존재한다.
- 따라서 공간 복잡도는 O(n)이 된다.

```java
int sum(int n) {
  if (n <= 0) {
    return 0;
  }
  return n + sum(n-1);
}

// 실제 스택이 깊어지며 호출이 쌓이는 모습
sum(3)
  -> sum(2)
    -> sum(1)
      -> sum(0)
```

- 단지 n번 호출했다고 공간복잡도가 O(n)이 되는 것은 아니다.
- 함수들이 호출 스택에 동시에 존재하지 않으면 실제 공간은 O(1)만 사용된다.

```java
int pairSumSeq(int n) {
  int sum = 0;
  for (int i = 0; i < n; i++) {
    sum += pairSum(i, i + 1);
  }
  return sum;
}

int pairSum(int a, int b) {
  return a + b;
}
```
